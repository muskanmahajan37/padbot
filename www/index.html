<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1,  target-densitydpi=device-dpi" />

    <link rel="stylesheet" type="text/css" href="css/index.css" />
    <title>Padbot</title>
</head>
<body>
<div class="app">
    <h1>Padbot2</h1>
    <div id="mainPage">
        <div id="credentials">
            <p>
                Connect as: <input type="text" id="caller-id" size="15">
                <button id="connect">Connect</button>
            </p>
        </div>

        <div id="dialler" data-active="false">
            <p>
                Make call to:
                <input type="select" id="recipient-id">
                </input>
                <button id="dial">Call</button>
            </p>

            <hr>

            <p><strong>REMOTE:</strong></p>
            <video id="remote-video" autoplay></video>

            <hr>

            <p><strong>LOCAL:</strong></p>
            <video id="local-video" autoplay muted></video>
        </div>

        <hr>

        <div id="messages">
        </div>
        <ul id="deviceList">
        </ul>
        <button id="refreshButton">Refresh</button>
    </div>
    <div id="detailPage">
        <div id="dynamic"></div>

        <div id="resultDiv"></div>
        <div>
            <input type="text" id="messageInput" value="Hello"/>
            <button id="sendButton">Send</button>
        </div>

        <button id="disconnectButton">Disconnect</button>
    </div>
</div>
<script type="text/javascript" src="cordova.js"></script>
<script type="text/javascript" src="js/nipplejs.min.js"></script>
<script type="text/javascript" src="js/socket.io-1.4.5.js"></script>
<script>
    var options = {
        zone: document.getElementById('dynamic'),
        mode: 'static',
        size: 200,
        position: {left: '50%', top: '30%'},
        color: 'red'
    };
    var manager = nipplejs.create(options);
</script>
<script type="text/javascript" src="js/index.js"></script>
<script type="text/javascript" src="js/peer.js"></script>
<script type="text/javascript">
    app.initialize();

    document.addEventListener('DOMContentLoaded', function () {
        // PeerJS server location
        var SERVER_IP = '10.29.2.168';
        var SERVER_PORT = 9000;

        // DOM elements manipulated as user interacts with the app
        var messageBox = document.querySelector('#messages');
        var callerIdEntry = document.querySelector('#caller-id');
        var connectBtn = document.querySelector('#connect');
        var recipientIdEntry = document.querySelector('#recipient-id');
        var dialBtn = document.querySelector('#dial');
        var remoteVideo = document.querySelector('#remote-video');
        var localVideo = document.querySelector('#local-video');

        // the ID set for this client
        var callerId = null;

        // PeerJS object, instantiated when this client connects with its
        // caller ID
        var peer = null;

        // the local video stream captured with getUserMedia()
        var localStream = null;

        // DOM utilities
        var makePara = function (text) {
            var p = document.createElement('p');
            p.innerText = text;
            return p;
        };

        var addMessage = function (para) {
            if (messageBox.firstChild) {
                messageBox.insertBefore(para, messageBox.firstChild);
            }
            else {
                messageBox.appendChild(para);
            }
        };

        var logError = function (text) {
            var p = makePara('ERROR: ' + text);
            p.style.color = 'red';
            addMessage(p);
        };

        var logMessage = function (text) {
            addMessage(makePara(text));
        };

        // get the local video and audio stream and show preview in the
        // "LOCAL" video element
        // successCb: has the signature successCb(stream); receives
        // the local video stream as an argument
        var getLocalStream = function (successCb) {
            if (localStream && successCb) {
                successCb(localStream);
            }
            else {
                navigator.webkitGetUserMedia(
                        {
                            audio: true,
                            video: true
                        },

                        function (stream) {
                            localStream = stream;

                            localVideo.src = window.URL.createObjectURL(stream);

                            if (successCb) {
                                successCb(stream);
                            }
                        },

                        function (err) {
                            logError('failed to access local camera');
                            logError(err.message);
                        }
                );
            }
        };

        // set the "REMOTE" video element source
        var showRemoteStream = function (stream) {
            remoteVideo.src = window.URL.createObjectURL(stream);
        };

        // set caller ID and connect to the PeerJS server
        var connect = function () {
            callerId = callerIdEntry.value;

            if (!callerId) {
                logError('please set caller ID first');
                return;
            }

            try {
                // create connection to the ID server
                peer = new Peer(callerId, {host: SERVER_IP, port: SERVER_PORT});

                // hack to get around the fact that if a server connection cannot
                // be established, the peer and its socket property both still have
                // open === true; instead, listen to the wrapped WebSocket
                // and show an error if its readyState becomes CLOSED
                peer.socket._socket.onclose = function () {
                    logError('no connection to server');
                    peer = null;
                };

                // get local stream ready for incoming calls once the wrapped
                // WebSocket is open
                peer.socket._socket.onopen = function () {
                    getLocalStream();
                };

                // handle events representing incoming calls
                peer.on('call', answer);
            }
            catch (e) {
                peer = null;
                logError('error while connecting to server');
            }
        };

        // make an outgoing call
        var dial = function () {
            if (!peer) {
                logError('please connect first');
                return;
            }

            if (!localStream) {
                logError('could not start call as there is no local camera');
                return
            }

            var recipientId = recipientIdEntry.value;

            if (!recipientId) {
                logError('could not start call as no recipient ID is set');
                return;
            }

            getLocalStream(function (stream) {
                logMessage('outgoing call initiated');

                var call = peer.call(recipientId, stream);

                call.on('stream', showRemoteStream);

                call.on('error', function (e) {
                    logError('error with call');
                    logError(e.message);
                });
            });
        };

        // answer an incoming call
        var answer = function (call) {
            if (!peer) {
                logError('cannot answer a call without a connection');
                return;
            }

            if (!localStream) {
                logError('could not answer call as there is no localStream ready');
                return;
            }

            logMessage('incoming call answered');

            call.on('stream', showRemoteStream);

            call.answer(localStream);
        };

        // wire up button events
        connectBtn.addEventListener('click', connect);
        dialBtn.addEventListener('click', dial);
    });

</script>
</body>
</html>
